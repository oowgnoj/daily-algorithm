### ***
- 1로 만들기(1463)
- 2xn 타일링(11726)
- 2xn 타일링2(11727)
- 1,2,3 더하기 (9095)
- 카드 구매하기 (11052)
- 카드 구매하기2 (16194)
- 1,2,3 더하기5 (15990)
- 쉬운 계단 수 (10844)
- 이친수(2193)
- 가장 긴 증가하는 부분 수열(11053)
- 가장 긴 증가하는 부분 수열4 (14002)
- 연속 합 (1912)
- 합분해 (2225)

### 연습

- 1,2,3 더하기 3(15988)
- RGB 거리(1149)
- 동물원 (1309)
- 오르막 수(11057)
- 스티커 (9465)
- 포도주 시식(2156)
- 정수 삼각형 (1932)
- 가장 큰 증가하는 부분 수열(11055)
- 가장 긴 바이토닉 부분 수열(11054)
- 연속 합 2 (13398)


## note
알고리즘 문제를 풀다보면, 해당 문제를 이해하고, 해결하는데에 집중하는 경우가 있다. 나같은 경우 초보자라 이것도 어렵게 느껴지는데, 궁극적으로 지향해야 하는 바는 문제 자체를 이해하고, 해결하는데 집중하기 보다는 
1. 어떻게 접근하고
2. 생각이 잘 나지 않을 때 어떻게 돌파하고
3. 여러가지 경우의 수를 생각해보고
4. 문제 자체보다 한 단계 위에서 추상화해 생각하자.


## note 
각 집을 빨강, 초록, 파랑으로 칠해야 한다. 
이 때 n 번째 집의 색은 n-1, n+1 의 집의 색과 동일하면 안된다
각 집을 칠하는데 최소값을 구하라

입력 예시
3
26 40 83
49 60 57
13 89 99

D[n] = D[n-1]까지의 최솟값 + min(D[n]을 빨강, 초록, 파랑중에 선택)
전 값이 R인지, G 인지, B 인지 알아야 한다.
점화식을 n-1 로 접근해서 풀기 어려웠던 것 같다. 절반이 맞았다고 볼 수 있다. 
한 차례에서 다음 계산에 꼭 필요한 것을 DP에 담는다.

````python
import sys
loop = int(sys.stdin.readline())
DP = [[0,0,0] for _ in range(1001)]
 
lst = [[0,0,0]]
ans = []
for i in range(1,loop+1):
    lst.append(list(map(int, str(input()).split(' '))))


for i in range(1, loop+1):
    DP[i][0] = min(DP[i-1][1], DP[i-1][2]) + lst[i][0]
    DP[i][1] = min(DP[i-1][0], DP[i-1][2]) + lst[i][1]
    DP[i][2] = min(DP[i-1][0], DP[i-1][1]) + lst[i][2]
    ans.append(min(DP[i]))
print(ans[-1])
````
