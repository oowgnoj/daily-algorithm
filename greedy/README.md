### GREEDY
그리디 알고리즘은 항상 최대값 또는 당장 좋은 것만 선택하여 최적해를 얻는 경우에 사용된다. 해당 문제가 그리디인 것을 파악한다면 접근하면 풀기가 쉬운 편이다.

#### 어떻게 그리디를 판단할까?

예시1) 다양한 동전으로 x원을 만들 수 있는 최솟값 ([백준 11047](https://www.acmicpc.net/problem/11047))
아래의 동전 리스트에서 최소한의 동전을 사용해 4200원을 만들었을 때 동전의 갯수를 구하는 프로그램을 작성해보자. (각각의 동전은 매우 많이 가지고 있다)
'최소한'의 조건이 없다면 1원짜리가 4200개 있거나, 5원짜리가 840개, 10원짜리가 420개 있어도 가능하다. 하지만 **최소한의 동전 갯수를 사용해야 한다면 가장 큰 동전부터 낼 수 있는 만큼 많이 내야한다** 이런 문제들이 전형적인 그리디 형태로 해결할 수 있는 문제다. 풀이 방법은 많은 것 부터 `//` 연산자를 사용하면 될 것 같다. 간단하니 넘어가자.

````python
1
5
10
50
100
500
1000
5000
10000
50000
````


예시2) (최대한 많은) 회의실 배정
아래 목록에서 첫번째 행에 해당하는 값은 회의의 갯수(N)이다. 두번째 줄 부터 N+1번째 줄 까지 시작시간과 끝나는 시간이 공백을 두고 주어진다. 최대 몇개의 회의가 열릴 수 있는지 갯수를 세는 프로그램을 만들자.

````python
11 # 회의의 갯수
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
````
회의를 최대한 많이 잡으려면, 어떻게 해야할까? **그리디 알고리즘에서 가장 큰 부분중 하나는 '과연 이 문제가 그리디 알고리즘으로 풀리는가 안풀리는가에 대한 사고다.'** 하나 더해서, 그리디 알고리즘이 적용될 수 있는 조건을 찾는데 **위 문제와는 다르게 그리디로 접근하기 위해 한개 이상의 조건이 있을 수 있다.** 이번 문제가 그런데, 이번 문제를 만났을 때 바로 떠오르는 해결법을 적어보자.
1. 가장 빨리 시작하는 회의
2. 가장 빨리 끝나는 회의

첫번째 경우에 대한 반례는 쉽게 찾을 수 있는데, 가장 빨리 시작하는 회의가 항상 가장 빨리 끝난다는 보장이 없다. ~~(출근부터 퇴근까지 회의를 하는 경우)~~. 
그렇다면 매 순간 가장 빨리 끝나는 회의를 추가한다면 어떨까? ~~(실제로 이렇게 제출했는데 틀렸다)~~
반례를 생각해보자. 회의는 시작해야 끝날 수 있다. 문제에서 시작시간과 끝나는 시간은 같을 수 있다고 했으니 `시작시간 <= 끝나는 시간` 이다. 
````python
5
4 4
4 4
3 4
2 4
1 4
````
위 예시에서 1~4, 2~4 혹은 3~4에 회의가 잡히고 4시에 끝난다. 그리고 4시에 진행되는 회의를 두 건 할수 있어 답은 총 3인데, 끝나는 시간만 기준으로 한다면 항상 3을 보장할 수 없다. 4~4에 진행되는 회의 두 건이 나머지 회의보다 위에 있게되면 먼저 현재 시간이 4로 등록되어 1,2,3시부터 시작할 수 있는 회의는 하나도 진행하지 못하게 된다. 디테일이 필요하다.

````python
n=int(input())
lst= [tuple(map(int, input().split(' '))) for _ in range(n)] 
lst.sort(key=lambda x: (x[1], x[0])) #끝나는 시간 -> 시작하는 시간 순으로 배열 정렬

cnt = 1
current = lst[0][1] #가장 빨리 끝나는 회의시간
for i in range(1, len(lst)):
    if current <= lst[i][1]:
        cnt +=1 #회의 갯수 더하기
        currnt = lst[i][0]
print(cnt)


````

다른 사람의 풀이를 보니, 시작 시간 -> 끝나는 시간 순으로 정렬을 한 경우도 있었다. 현재 시간에서 가장 빨리 시작하는 회의 중 가장 빨리 끝나는 회의만을 선택하는 그리디 알고리즘으로 해결하는 경우다. 이 풀이가 조금 더 직관적일 수 있겠다.

예시 3) ATM 기다리는 시간 최소화

출제자가 그리디 문제를 평이하게 출제하려는 경우 무언가 명확하다는 느낌이 든다. 위 두 문제를 포함해 이번 문제도 최대화/최소화 하는 문제 중 하나다.
이번 문제는 ATM을 기다리는 사람의 수와, ATM에서 용무를 시작해서 끝내는데 까지 걸리는 시간이 배열로 주어진다. ~~(초등학생도 풀 수 있을 것 같다)~~
````python
5 # 명 수
3 1 4 3 2 # 처리하는데 걸리는 시간
````
기다리는 시간을 최소화하기 위해, 가장 빨리 끝나는 사람이 가장 먼저 용무를 해결하면 된다. 따라서 오름차순으로 정렬하고, 값을 더해주면 될 거라고 생각한다.

예시 4) 주유소 (기름값 최소화)

입력
````python
4 # 도시의 개수 (A, B, C, D)
2 3 1 # 도로의 길이 (a->b : 2)
5 2 4 1 # 각 도시의 리터당 가격 (1리터 : 1)
````

'최소화'도 그렇고, 느낌적으로 그리디의 냄새가 강하게 난다. 적용할 수 있는 로직을 찾아보자.
먼저 가장 첫번째 도시의 기름값이 가장 싸다면 도시를 가로질러 끝까지 갈 수 있는 충분한 기름을 넣으면 된다. (만약 서울에서 부산으로 간다고 했을 때 부산으로 갈수록 기름값이 비싸다는 사실을 알면 아마 기름 탱크를 가득 채워 갈 것이다.) 하지만 이번 경우에는 그렇지가 않다. 중간에 기름이 싼 도시(예를 들면 대전)이 있을수도 있어 비교를 해주어야 한다.

그렇다면 서울에서 최선의 선택은 기름값을 미리 확인하여, 중간에 서울보다 기름값이 싼 도시 까지만 기름을 넣어 가는 것이다.

````python
n=int(input())
distance=list(map(int, input().split(' ')))
oil_price=list(map(int, input().split(' ')))

ans = 0
P = oil_price[0]
D = distance[0]

for i in range(1, len(oil_price)-1):
    if P > prices[i]:
        ans += D * P
        P = oil_price[i]
        D = distance[i]
    else:
        D += distance[i]

if D:
    ans += P * D


````

 지금 도시보다 다음 도시가 기름값이 싼 경우, 다음 도시로 